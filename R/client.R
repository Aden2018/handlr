handlr_readers <- c('citeproc', 'ris', 'bibtex', 'codemeta')
handlr_writers <- c('citeproc', 'ris', 'bibtex', 'schema_org', 
  'rdfxml', 'codemeta')

#' handlr client
#'
#' @export
#' @param x (character) a file path (the file must exist), a string 
#' containing contents of the citation, a DOI, or a DOI as a URL. 
#' See Details.
#' 
#' @details
#' **Methods**
#' 
#' * `read(format = NULL, ...)` - read input
#'     * `format`: one of citeproc, ris, bibtex, codemeta, or `NULL`. If `NULL`,
#'       we attempt to guess the format, and error if we can not guess
#'     * `...`: further args to the writer fxn, if any
#' 
#' * `write(format, file = NULL, ...)` - write to std out or file
#'     * `format`: one of citeproc, ris, bibtex, rdfxml
#'     * `file`: a file path, if NULL to stdout
#'     * `...`: further args to the writer fxn, if any
#'     * Note: If `$parsed` is `NULL` then it's likely `$read()` has not 
#'       been run - in which case we attempt to run `$read()` to 
#'       populate `$parsed`
#'
#' @format NULL
#' @usage NULL
#' 
#' @details The various inputs to the `x` parameter are handled in different
#' ways:
#' 
#' - file: contents read from file, we grab file extension, and we guess 
#' format based on combination of contents and file extension because 
#' file extensions may belie what's in the file
#' - string: string read in, and we guess format based on contents of
#' the string
#' - DOI: we request citeproc-json format from the Crossref API
#' - DOI url: we request citeproc-json format from the Crossref API
#' 
#' @examples
#' # read() can be run with format specified or not
#' # if format not given, we attempt to guess the format and then read
#' z <- system.file('extdata/citeproc.json', package = "handlr")
#' (x <- HandlrClient$new(x = z))
#' x$read()
#' x$read("citeproc")
#' 
#' # you can run read() then write() 
#' # or just run write(), and read() will be run for you if possible
#' z <- system.file('extdata/citeproc.json', package = "handlr")
#' (x <- HandlrClient$new(x = z))
#' cat(x$write("ris"))
#' 
#' # read from a url
#' (x <- HandlrClient$new('https://doi.org/10.7554/elife.01567'))
#' x$parsed
#' x$read()
#' x$write('bibtex')
#' 
#' # read from a DOI
#' (x <- HandlrClient$new('10.7554/elife.01567'))
#' x$parsed
#' x$read()
#' x$write('bibtex')
#' 
#' # Example of specific formats
#' # crosscite
#' z <- system.file('extdata/crosscite.json', package = "handlr")
#' (x <- HandlrClient$new(x = z))
#' x$path
#' 
#' # read in citeproc, write out bibtex
#' z <- system.file('extdata/citeproc.json', package = "handlr")
#' (x <- HandlrClient$new(x = z))
#' x$path
#' x$ext
#' x$read("citeproc")
#' x$parsed
#' x$write("bibtex")
#' f <- tempfile(fileext = ".bib")
#' x$write("bibtex", file = f)
#' readLines(f)
#' unlink(f)
#' 
#' # read in ris, write out ris
#' z <- system.file('extdata/peerj.ris', package = "handlr")
#' (x <- HandlrClient$new(x = z))
#' x$path
#' x$format
#' x$read("ris")
#' x$parsed
#' x$write("ris")
#' cat(x$write("ris"))
#' 
#' # read in bibtex, write out ris
#' (z <- system.file('extdata/bibtex.bib', package = "handlr"))
#' (x <- HandlrClient$new(x = z))
#' x$path
#' x$format
#' x$read("bibtex")
#' x$parsed
#' x$write("ris")
#' cat(x$write("ris"))
#' 
#' # read in bibtex, write out RDF XML
#' (z <- system.file('extdata/bibtex.bib', package = "handlr"))
#' (x <- HandlrClient$new(x = z))
#' x$path
#' x$format
#' x$read("bibtex")
#' x$parsed
#' x$write("rdfxml")
#' cat(x$write("rdfxml"))
#' 
#' # codemeta
#' (z <- system.file('extdata/codemeta.json', package = "handlr"))
#' (x <- HandlrClient$new(x = z))
#' x$path
#' x$format
#' x$read("codemeta")
#' x$parsed
#' x$write("codemeta")
#' 
#' # handle strings instead of files
#' z <- system.file('extdata/citeproc-crossref.json', package = "handlr")
#' (x <- HandlrClient$new(x = readLines(z)))
#' x$read("citeproc")
#' x$parsed
#' cat(x$write("bibtex"), sep = "\n")
HandlrClient <- R6::R6Class(
  'HandlrClient',
  public = list(
    path = NULL,
    string = NULL,
    substring = NULL,
    parsed = NULL,
    file = FALSE,
    ext = NULL,
    format_guessed = NULL,
    doi = NULL,

    print = function(x, ...) {
      cat("<handlr> ", sep = "\n")
      cat(paste0("  doi: ", self$doi), sep = "\n")
      cat(paste0("  ext: ", self$ext), sep = "\n")
      cat(paste0("  format (guessed): ", self$format_guessed), sep = "\n")
      cat(paste0("  path: ", self$path %||% "none"), sep = "\n")
      cat(paste0("  string (abbrev.): ", self$substring %||% "none"), sep = "\n")
      invisible(self)
    },

    initialize = function(x) {
      assert(x, "character")
      if (is_url_doi(x) || is_doi(x)) {
        self$doi <- urltools::url_decode(doi_from_url(normalize_doi(x)))
        x <- get_doi(self$doi)
      }
      if (is_file(x)) {
        self$file <- TRUE
        self$path <- x
      }
      if (!is_file(x)) {
        if (!nzchar(x)) stop("input is zero length string")
        self$string <- x
        self$substring <- substring(x, 1, 80)
      }
      self$ext <- private$find_ext(x)
      self$format_guessed <- private$guess_format(x)
    },

    read = function(format = NULL, ...) {
      if (is.null(format)) format <- self$format_guessed
      self$parsed <- switch(
        format,
        citeproc = citeproc_reader(self$path %||% self$string, ...),
        ris = ris_reader(self$path %||% self$string, ...),
        bibtex = bibtex_reader(self$path %||% self$string, ...),
        codemeta = codemeta_reader(self$path %||% self$string, ...),
        stop("format must be one of ", 
          paste(handlr_readers, collapse = ", "))
      )
    },

    write = function(format, file = NULL, ...) {
      if (is.null(self$parsed)) self$read()
      out <- switch(
        format,
        citeproc = citeproc_writer(self$parsed, ...),
        ris = ris_writer(self$parsed, ...),
        bibtex = bibtex_writer(self$parsed, ...),
        schema_org = schema_org_writer(self$parsed, ...),
        rdfxml = rdf_xml_writer(self$parsed, ...),
        codemeta = codemeta_writer(self$parsed, ...),
        stop("format must be one of ",
          paste(handlr_writers, collapse = ", "))
      )
      if (is.null(file)) return(out)
      cat(out, "\n", file = file)
    }
  ),

  private = list(
    find_ext = function(x) {
      if (!file.exists(x)) return(NULL)
      tmp <- strsplit(basename(x), "\\.")[[1]]
      tmp[length(tmp)]
    },

    guess_format = function(x) {
      reader_funs <- paste0(handlr_readers, "_reader")
      read_attempts <- vapply(reader_funs, function(fun) {
        tmp <- tryCatch(suppressWarnings(eval(parse(text=fun))(x)), 
          error = function(e) e)
        !inherits(tmp, "error")
      }, logical(1L))
      if (!any(read_attempts) || length(which(read_attempts)) > 1) {
        if (length(which(read_attempts)) > 1) {
          if (json_val(x)) {
            # json types
            type <- "citeproc"
            if (any(grepl("@context", readLines(x)))) type <- "codemeta"
            return(type)
          } else {
            # check for bibtex type
            ## if file does not have .bib extension then we'll fail 
            if (
              "bibtex_reader" %in% names(which(read_attempts)) && 
              self$ext == "bib"
            ) {
              return("bibtex")
            }
          }
        }
        stop("could not guess format for string; specify format")
      } else {
        return(handlr_readers[read_attempts])
      }
    }
  )
)

json_val <- function(x) {
  b <- tryCatch(jsonlite::fromJSON(x), error = function(e) e)
  !inherits(b, "error")
}
